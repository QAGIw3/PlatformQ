"""
Transaction Monitoring System for real-time compliance checks
"""

import logging
import asyncio
from typing import Dict, Any, List, Optional, Set
from datetime import datetime, timedelta
from dataclasses import dataclass
from enum import Enum
from decimal import Decimal

from pyignite import Client as IgniteClient
import pulsar
import httpx

logger = logging.getLogger(__name__)


class MonitoringRule(Enum):
    """Types of monitoring rules"""
    VELOCITY = "velocity"
    AMOUNT_THRESHOLD = "amount_threshold"
    PATTERN = "pattern"
    GEOGRAPHY = "geography"
    COUNTERPARTY = "counterparty"
    TIME_BASED = "time_based"


@dataclass
class MonitoringAlert:
    """Alert generated by monitoring system"""
    alert_id: str
    rule_type: MonitoringRule
    severity: str
    transaction_ids: List[str]
    user_id: str
    description: str
    triggered_at: datetime
    metadata: Dict[str, Any]


class TransactionMonitor:
    """
    Real-time transaction monitoring system
    """
    
    def __init__(
        self,
        ignite_client: IgniteClient,
        pulsar_client: pulsar.Client,
        aml_engine,
        risk_assessment_engine
    ):
        self.ignite_client = ignite_client
        self.pulsar_client = pulsar_client
        self.aml_engine = aml_engine
        self.risk_assessment_engine = risk_assessment_engine
        
        # Caches
        self._rules_cache = None
        self._monitoring_cache = None
        self._alerts_cache = None
        
        # Event consumers/producers
        self.transaction_consumer = None
        self.alert_producer = None
        
        # Monitoring state
        self._active_rules = {}
        self._monitoring_task = None
        
    async def initialize(self):
        """Initialize the transaction monitor"""
        # Initialize caches
        self._rules_cache = await self.ignite_client.get_or_create_cache(
            "monitoring_rules"
        )
        self._monitoring_cache = await self.ignite_client.get_or_create_cache(
            "transaction_monitoring"
        )
        self._alerts_cache = await self.ignite_client.get_or_create_cache(
            "monitoring_alerts"
        )
        
        # Initialize Pulsar
        self.transaction_consumer = self.pulsar_client.subscribe(
            'persistent://public/blockchain/transactions',
            'compliance-monitor'
        )
        
        self.alert_producer = self.pulsar_client.create_producer(
            'persistent://public/compliance/monitoring-alerts'
        )
        
        # Load monitoring rules
        await self._load_monitoring_rules()
        
        # Start monitoring
        self._monitoring_task = asyncio.create_task(self._monitoring_loop())
        
        logger.info("Transaction monitor initialized")
        
    async def shutdown(self):
        """Shutdown the transaction monitor"""
        if self._monitoring_task:
            self._monitoring_task.cancel()
            await asyncio.gather(self._monitoring_task, return_exceptions=True)
            
        if self.transaction_consumer:
            await self.transaction_consumer.close()
            
        if self.alert_producer:
            self.alert_producer.close()
            
        logger.info("Transaction monitor shutdown")
        
    async def _load_monitoring_rules(self):
        """Load active monitoring rules"""
        self._active_rules = {
            MonitoringRule.VELOCITY: {
                "enabled": True,
                "config": {
                    "max_transactions_per_hour": 10,
                    "max_transactions_per_day": 50,
                    "max_volume_per_hour": Decimal("100000"),
                    "max_volume_per_day": Decimal("500000")
                }
            },
            MonitoringRule.AMOUNT_THRESHOLD: {
                "enabled": True,
                "config": {
                    "single_transaction_alert": Decimal("50000"),
                    "single_transaction_block": Decimal("500000"),
                    "cumulative_24h_alert": Decimal("200000")
                }
            },
            MonitoringRule.PATTERN: {
                "enabled": True,
                "config": {
                    "structuring_threshold": 0.9,
                    "round_amount_count": 5,
                    "time_pattern_window": 3600  # 1 hour
                }
            },
            MonitoringRule.GEOGRAPHY: {
                "enabled": True,
                "config": {
                    "high_risk_countries": ["IR", "KP", "SY", "CU", "VE"],
                    "require_enhanced_for_cross_border": True
                }
            },
            MonitoringRule.COUNTERPARTY: {
                "enabled": True,
                "config": {
                    "max_unique_counterparties_per_day": 20,
                    "blacklisted_addresses": set(),
                    "high_risk_services": ["mixer", "tumbler", "anonymous"]
                }
            },
            MonitoringRule.TIME_BASED: {
                "enabled": True,
                "config": {
                    "unusual_hours": [0, 1, 2, 3, 4, 5],  # 12am-6am
                    "rapid_succession_minutes": 5,
                    "dormant_account_days": 180
                }
            }
        }
        
    async def _monitoring_loop(self):
        """Main monitoring loop for processing transactions"""
        while True:
            try:
                # Receive transaction event
                msg = await self.transaction_consumer.receive_async()
                
                try:
                    # Parse transaction
                    transaction = msg.data()
                    
                    # Process transaction
                    await self._process_transaction(transaction)
                    
                    # Acknowledge message
                    await self.transaction_consumer.acknowledge_async(msg)
                    
                except Exception as e:
                    logger.error(f"Error processing transaction: {e}")
                    # Negative acknowledge for retry
                    await self.transaction_consumer.negative_acknowledge(msg)
                    
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Error in monitoring loop: {e}")
                await asyncio.sleep(1)
                
    async def _process_transaction(self, transaction: Dict[str, Any]):
        """Process a single transaction through all monitoring rules"""
        user_id = transaction.get("user_id")
        transaction_id = transaction.get("transaction_id")
        
        logger.info(f"Processing transaction {transaction_id} for user {user_id}")
        
        # Store transaction
        await self._store_transaction(transaction)
        
        # Run AML checks
        risk_assessment = await self.aml_engine.assess_transaction_risk(
            transaction_id=transaction_id,
            user_id=user_id,
            from_address=transaction.get("from_address"),
            to_address=transaction.get("to_address"),
            amount_usd=Decimal(str(transaction.get("amount_usd", 0))),
            asset_type=transaction.get("asset_type"),
            chain=transaction.get("chain"),
            user_kyc_level=transaction.get("kyc_level"),
            metadata=transaction.get("metadata", {})
        )
        
        # Run monitoring rules
        alerts = []
        
        if self._active_rules[MonitoringRule.VELOCITY]["enabled"]:
            velocity_alerts = await self._check_velocity_rule(user_id, transaction)
            alerts.extend(velocity_alerts)
            
        if self._active_rules[MonitoringRule.AMOUNT_THRESHOLD]["enabled"]:
            amount_alerts = await self._check_amount_rule(user_id, transaction)
            alerts.extend(amount_alerts)
            
        if self._active_rules[MonitoringRule.PATTERN]["enabled"]:
            pattern_alerts = await self._check_pattern_rule(user_id, transaction)
            alerts.extend(pattern_alerts)
            
        if self._active_rules[MonitoringRule.GEOGRAPHY]["enabled"]:
            geo_alerts = await self._check_geography_rule(user_id, transaction)
            alerts.extend(geo_alerts)
            
        if self._active_rules[MonitoringRule.COUNTERPARTY]["enabled"]:
            counterparty_alerts = await self._check_counterparty_rule(user_id, transaction)
            alerts.extend(counterparty_alerts)
            
        if self._active_rules[MonitoringRule.TIME_BASED]["enabled"]:
            time_alerts = await self._check_time_rule(user_id, transaction)
            alerts.extend(time_alerts)
            
        # Process alerts
        for alert in alerts:
            await self._process_alert(alert)
            
        # Check if transaction should be blocked
        should_block = (
            risk_assessment.risk_level.value == "CRITICAL" or
            any(alert.severity == "CRITICAL" for alert in alerts)
        )
        
        if should_block:
            await self._block_transaction(transaction_id, alerts)
            
    async def _store_transaction(self, transaction: Dict[str, Any]):
        """Store transaction for monitoring"""
        user_id = transaction.get("user_id")
        transaction_id = transaction.get("transaction_id")
        
        # Store in user's transaction list
        user_key = f"user_monitoring:{user_id}"
        user_data = await self._monitoring_cache.get(user_key) or {
            "transactions": [],
            "last_activity": None,
            "total_volume_24h": "0",
            "unique_counterparties_24h": set()
        }
        
        # Add transaction
        user_data["transactions"].append({
            "id": transaction_id,
            "timestamp": transaction.get("timestamp"),
            "amount_usd": transaction.get("amount_usd"),
            "to_address": transaction.get("to_address"),
            "from_address": transaction.get("from_address")
        })
        
        # Update metrics
        user_data["last_activity"] = transaction.get("timestamp")
        
        # Keep only last 7 days of transactions
        cutoff = (datetime.utcnow() - timedelta(days=7)).isoformat()
        user_data["transactions"] = [
            t for t in user_data["transactions"]
            if t["timestamp"] > cutoff
        ]
        
        await self._monitoring_cache.put(user_key, user_data)
        
    async def _check_velocity_rule(
        self,
        user_id: str,
        transaction: Dict[str, Any]
    ) -> List[MonitoringAlert]:
        """Check velocity monitoring rules"""
        alerts = []
        config = self._active_rules[MonitoringRule.VELOCITY]["config"]
        
        # Get user monitoring data
        user_key = f"user_monitoring:{user_id}"
        user_data = await self._monitoring_cache.get(user_key) or {"transactions": []}
        
        now = datetime.utcnow()
        hour_ago = now - timedelta(hours=1)
        day_ago = now - timedelta(days=1)
        
        # Parse transactions
        transactions = []
        for t in user_data["transactions"]:
            transactions.append({
                "timestamp": datetime.fromisoformat(t["timestamp"]),
                "amount": Decimal(t["amount_usd"])
            })
            
        # Check hourly velocity
        hourly_txns = [t for t in transactions if t["timestamp"] > hour_ago]
        hourly_count = len(hourly_txns) + 1  # Include current
        hourly_volume = sum(t["amount"] for t in hourly_txns) + Decimal(transaction["amount_usd"])
        
        if hourly_count > config["max_transactions_per_hour"]:
            alerts.append(MonitoringAlert(
                alert_id=f"velocity_hourly_count_{transaction['transaction_id']}",
                rule_type=MonitoringRule.VELOCITY,
                severity="HIGH",
                transaction_ids=[transaction["transaction_id"]],
                user_id=user_id,
                description=f"High hourly transaction velocity: {hourly_count} transactions",
                triggered_at=now,
                metadata={"hourly_count": hourly_count, "limit": config["max_transactions_per_hour"]}
            ))
            
        if hourly_volume > config["max_volume_per_hour"]:
            alerts.append(MonitoringAlert(
                alert_id=f"velocity_hourly_volume_{transaction['transaction_id']}",
                rule_type=MonitoringRule.VELOCITY,
                severity="HIGH",
                transaction_ids=[transaction["transaction_id"]],
                user_id=user_id,
                description=f"High hourly transaction volume: ${hourly_volume}",
                triggered_at=now,
                metadata={"hourly_volume": str(hourly_volume), "limit": str(config["max_volume_per_hour"])}
            ))
            
        # Check daily velocity
        daily_txns = [t for t in transactions if t["timestamp"] > day_ago]
        daily_count = len(daily_txns) + 1
        daily_volume = sum(t["amount"] for t in daily_txns) + Decimal(transaction["amount_usd"])
        
        if daily_count > config["max_transactions_per_day"]:
            alerts.append(MonitoringAlert(
                alert_id=f"velocity_daily_count_{transaction['transaction_id']}",
                rule_type=MonitoringRule.VELOCITY,
                severity="MEDIUM",
                transaction_ids=[transaction["transaction_id"]],
                user_id=user_id,
                description=f"High daily transaction velocity: {daily_count} transactions",
                triggered_at=now,
                metadata={"daily_count": daily_count, "limit": config["max_transactions_per_day"]}
            ))
            
        return alerts
        
    async def _check_amount_rule(
        self,
        user_id: str,
        transaction: Dict[str, Any]
    ) -> List[MonitoringAlert]:
        """Check amount threshold rules"""
        alerts = []
        config = self._active_rules[MonitoringRule.AMOUNT_THRESHOLD]["config"]
        amount = Decimal(transaction["amount_usd"])
        
        # Single transaction thresholds
        if amount >= config["single_transaction_block"]:
            alerts.append(MonitoringAlert(
                alert_id=f"amount_block_{transaction['transaction_id']}",
                rule_type=MonitoringRule.AMOUNT_THRESHOLD,
                severity="CRITICAL",
                transaction_ids=[transaction["transaction_id"]],
                user_id=user_id,
                description=f"Transaction exceeds blocking threshold: ${amount}",
                triggered_at=datetime.utcnow(),
                metadata={"amount": str(amount), "threshold": str(config["single_transaction_block"])}
            ))
        elif amount >= config["single_transaction_alert"]:
            alerts.append(MonitoringAlert(
                alert_id=f"amount_alert_{transaction['transaction_id']}",
                rule_type=MonitoringRule.AMOUNT_THRESHOLD,
                severity="HIGH",
                transaction_ids=[transaction["transaction_id"]],
                user_id=user_id,
                description=f"High value transaction: ${amount}",
                triggered_at=datetime.utcnow(),
                metadata={"amount": str(amount), "threshold": str(config["single_transaction_alert"])}
            ))
            
        # Check cumulative amount
        user_key = f"user_monitoring:{user_id}"
        user_data = await self._monitoring_cache.get(user_key) or {"transactions": []}
        
        day_ago = datetime.utcnow() - timedelta(days=1)
        daily_total = Decimal("0")
        
        for t in user_data["transactions"]:
            if datetime.fromisoformat(t["timestamp"]) > day_ago:
                daily_total += Decimal(t["amount_usd"])
                
        daily_total += amount
        
        if daily_total > config["cumulative_24h_alert"]:
            alerts.append(MonitoringAlert(
                alert_id=f"amount_cumulative_{transaction['transaction_id']}",
                rule_type=MonitoringRule.AMOUNT_THRESHOLD,
                severity="HIGH",
                transaction_ids=[transaction["transaction_id"]],
                user_id=user_id,
                description=f"High 24h cumulative amount: ${daily_total}",
                triggered_at=datetime.utcnow(),
                metadata={"daily_total": str(daily_total), "threshold": str(config["cumulative_24h_alert"])}
            ))
            
        return alerts
        
    async def _check_pattern_rule(
        self,
        user_id: str,
        transaction: Dict[str, Any]
    ) -> List[MonitoringAlert]:
        """Check for suspicious patterns"""
        alerts = []
        config = self._active_rules[MonitoringRule.PATTERN]["config"]
        
        # This would implement pattern detection similar to AML engine
        # For brevity, returning empty list
        return alerts
        
    async def _check_geography_rule(
        self,
        user_id: str,
        transaction: Dict[str, Any]
    ) -> List[MonitoringAlert]:
        """Check geography-based rules"""
        alerts = []
        config = self._active_rules[MonitoringRule.GEOGRAPHY]["config"]
        
        metadata = transaction.get("metadata", {})
        destination_country = metadata.get("destination_country")
        
        if destination_country in config["high_risk_countries"]:
            alerts.append(MonitoringAlert(
                alert_id=f"geo_high_risk_{transaction['transaction_id']}",
                rule_type=MonitoringRule.GEOGRAPHY,
                severity="HIGH",
                transaction_ids=[transaction["transaction_id"]],
                user_id=user_id,
                description=f"Transaction to high-risk jurisdiction: {destination_country}",
                triggered_at=datetime.utcnow(),
                metadata={"country": destination_country}
            ))
            
        if metadata.get("cross_border") and config["require_enhanced_for_cross_border"]:
            kyc_level = transaction.get("kyc_level", "unverified")
            if kyc_level in ["unverified", "tier_1"]:
                alerts.append(MonitoringAlert(
                    alert_id=f"geo_cross_border_{transaction['transaction_id']}",
                    rule_type=MonitoringRule.GEOGRAPHY,
                    severity="MEDIUM",
                    transaction_ids=[transaction["transaction_id"]],
                    user_id=user_id,
                    description="Cross-border transaction requires enhanced KYC",
                    triggered_at=datetime.utcnow(),
                    metadata={"kyc_level": kyc_level}
                ))
                
        return alerts
        
    async def _check_counterparty_rule(
        self,
        user_id: str,
        transaction: Dict[str, Any]
    ) -> List[MonitoringAlert]:
        """Check counterparty-based rules"""
        alerts = []
        config = self._active_rules[MonitoringRule.COUNTERPARTY]["config"]
        
        to_address = transaction.get("to_address")
        
        # Check blacklist
        if to_address in config["blacklisted_addresses"]:
            alerts.append(MonitoringAlert(
                alert_id=f"counterparty_blacklist_{transaction['transaction_id']}",
                rule_type=MonitoringRule.COUNTERPARTY,
                severity="CRITICAL",
                transaction_ids=[transaction["transaction_id"]],
                user_id=user_id,
                description=f"Transaction to blacklisted address: {to_address}",
                triggered_at=datetime.utcnow(),
                metadata={"address": to_address}
            ))
            
        # Check blockchain analytics if available
        if self.risk_assessment_engine:
            analytics = await self.risk_assessment_engine.analyze_blockchain_address(
                to_address,
                transaction.get("chain", "ethereum")
            )
            
            for provider, analysis in analytics.items():
                for service in config["high_risk_services"]:
                    if service in analysis.risk_category.lower():
                        alerts.append(MonitoringAlert(
                            alert_id=f"counterparty_risk_{transaction['transaction_id']}",
                            rule_type=MonitoringRule.COUNTERPARTY,
                            severity="HIGH",
                            transaction_ids=[transaction["transaction_id"]],
                            user_id=user_id,
                            description=f"Transaction to {service} service",
                            triggered_at=datetime.utcnow(),
                            metadata={"service": service, "provider": provider}
                        ))
                        break
                        
        return alerts
        
    async def _check_time_rule(
        self,
        user_id: str,
        transaction: Dict[str, Any]
    ) -> List[MonitoringAlert]:
        """Check time-based rules"""
        alerts = []
        config = self._active_rules[MonitoringRule.TIME_BASED]["config"]
        
        transaction_time = datetime.fromisoformat(transaction.get("timestamp"))
        
        # Check unusual hours
        if transaction_time.hour in config["unusual_hours"]:
            alerts.append(MonitoringAlert(
                alert_id=f"time_unusual_{transaction['transaction_id']}",
                rule_type=MonitoringRule.TIME_BASED,
                severity="LOW",
                transaction_ids=[transaction["transaction_id"]],
                user_id=user_id,
                description=f"Transaction during unusual hours: {transaction_time.hour}:00",
                triggered_at=datetime.utcnow(),
                metadata={"hour": transaction_time.hour}
            ))
            
        # Check dormant account reactivation
        user_key = f"user_monitoring:{user_id}"
        user_data = await self._monitoring_cache.get(user_key)
        
        if user_data and user_data.get("last_activity"):
            last_activity = datetime.fromisoformat(user_data["last_activity"])
            days_dormant = (transaction_time - last_activity).days
            
            if days_dormant > config["dormant_account_days"]:
                alerts.append(MonitoringAlert(
                    alert_id=f"time_dormant_{transaction['transaction_id']}",
                    rule_type=MonitoringRule.TIME_BASED,
                    severity="MEDIUM",
                    transaction_ids=[transaction["transaction_id"]],
                    user_id=user_id,
                    description=f"Dormant account reactivated after {days_dormant} days",
                    triggered_at=datetime.utcnow(),
                    metadata={"days_dormant": days_dormant}
                ))
                
        return alerts
        
    async def _process_alert(self, alert: MonitoringAlert):
        """Process and store alert"""
        # Store alert
        await self._alerts_cache.put(alert.alert_id, alert)
        
        # Emit alert event
        if self.alert_producer:
            import json
            self.alert_producer.send(
                json.dumps({
                    "alert_id": alert.alert_id,
                    "rule_type": alert.rule_type.value,
                    "severity": alert.severity,
                    "user_id": alert.user_id,
                    "description": alert.description,
                    "triggered_at": alert.triggered_at.isoformat(),
                    "metadata": alert.metadata
                }).encode('utf-8')
            )
            
        logger.info(f"Alert generated: {alert.alert_id} - {alert.description}")
        
    async def _block_transaction(
        self,
        transaction_id: str,
        alerts: List[MonitoringAlert]
    ):
        """Block a transaction"""
        logger.warning(f"BLOCKING TRANSACTION {transaction_id}")
        
        # Emit blocking event
        if self.alert_producer:
            import json
            self.alert_producer.send(
                json.dumps({
                    "event": "transaction_blocked",
                    "transaction_id": transaction_id,
                    "alerts": [a.alert_id for a in alerts],
                    "timestamp": datetime.utcnow().isoformat()
                }).encode('utf-8')
            )
            
    async def get_user_monitoring_summary(
        self,
        user_id: str
    ) -> Dict[str, Any]:
        """Get monitoring summary for a user"""
        user_key = f"user_monitoring:{user_id}"
        user_data = await self._monitoring_cache.get(user_key) or {}
        
        # Get recent alerts
        alerts = []
        cursor = self._alerts_cache.scan()
        for _, alert in cursor:
            if alert.user_id == user_id:
                alerts.append({
                    "alert_id": alert.alert_id,
                    "rule_type": alert.rule_type.value,
                    "severity": alert.severity,
                    "description": alert.description,
                    "triggered_at": alert.triggered_at.isoformat()
                })
                
        return {
            "user_id": user_id,
            "last_activity": user_data.get("last_activity"),
            "total_transactions": len(user_data.get("transactions", [])),
            "recent_alerts": sorted(
                alerts,
                key=lambda x: x["triggered_at"],
                reverse=True
            )[:10]
        } 